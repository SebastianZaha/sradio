#++
# A set of Rake tasks for building the Sradio project, organized as
# as TaskLib which is called from the project Rakefile.
#
# It's just an adapted and stripped down version of Alexandria's
# tasklib, which in turn is based upon 'hoe' by Ryan Davis.
#
# http://alexandria.rubyforge.org/
# http://rubyforge.org/projects/seattlerb/
#
# Copyright (c) 2006,2007 Ryan Davis, Zen Spider Software
# Copyright (c) 2007 Cathal Mc Ginley, Gnostai
#
# This file is free software, under the terms of the MIT License.
#--
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# these requirements are part of core ruby
require 'pathname'
require 'rbconfig'
require 'yaml'

require 'rake'
require 'rake/tasklib'
require 'rake/rdoctask'
require 'rake/packagetask'


class SradioBuild < Rake::TaskLib

  attr_accessor :name, :version, :rubyforge_name
  attr_accessor :author, :email, :summary, :description

  # config objects
  attr_accessor :files
  attr_accessor :install
  attr_accessor :debinstall

  def initialize(name, version)
    @name = name
    @version = version
    @rubyforge_name = name.downcase

    @files = FileConfig.new(self)
    @install = InstallConfig.new(self)
    @debinstall = DebianInstallConfig.new(self)

    yield self if block_given?
    define_tasks
  end

  def autogen_comment
    autogenerated_warning = "This file is automatically generated by the installer.\nDo not edit it directly."
    lines = autogenerated_warning.split("\n")
    result = lines.map { |line| "# #{line}"}
    result.join("\n") + "\n\n"
  end

  def generate(filename)
    File.open(filename, 'w') do |file|
      puts "Generating #{filename}"
      file.print autogen_comment
      file_contents = yield
      file.print file_contents.to_s
    end
  end

  class BuildConfig
    def initialize(build)
      @build = build
    end
    protected
    def build
      @build
    end
  end

  class FileConfig < BuildConfig
    attr_accessor :source, :rdoc, :data, :icons
    def initialize(build)
      super(build)
    end
    def libs
      source.grep(/^lib/)
    end
    def programs
      source.grep(/^bin/)
    end
  end


  def define_tasks
    define_clean_tasks
    define_package_tasks
    define_install_tasks
    define_debinstall_tasks
  end

  # Defines :clean and :clobber tasks from Rake's built-in definitions.
  def define_clean_tasks
    require 'rake/clean'
  end


  ## # # # package tasks # # # ##

  def define_package_tasks
      namespace 'pkg' do
      Rake::PackageTask.new(@name, @version) do |p|
          p.need_tar_gz = true
          p.package_files.include("Rakefile", "tasks.rb", "bin/**/*", "share/**/*", "debian/**/*", "lib/**/*")
      end
      end
      task :clobber => ['pkg:clobber_package']
  end

  ## # # # install tasks # # # ##

  def install_file(src_dir, file, dest_dir, mode)
    source_basedir = Pathname.new(src_dir)
    source_file = Pathname.new(file)
    dest_basedir = Pathname.new(dest_dir)
    if source_file.file?
      source_path = source_file.dirname.relative_path_from(source_basedir)
    end
    dest = source_path ? dest_basedir + source_path : dest_basedir
    FileUtils.mkdir_p dest unless test ?d, dest
    puts "Installing #{file} to #{dest}"
    File.install(file.to_s, dest.to_s, mode)
  end

  def define_install_tasks
    task :pre_install # just an empty hook

    task :install_files do
      @install.groups.each do |src, files, dest, mode|
        files.each do |file|
          install_file(src, file, dest, mode)
        end
      end
    end

    task :post_install # another empty hook

    desc "Install the package. Override destination with $PREFIX"
    task :install => [:pre_install, :install_files, :post_install]

  end


  class InstallConfig < BuildConfig

    attr_accessor :prefix, :rubylib

    def initialize(build)
      super(build)
      ruby_prefix = Config::CONFIG['prefix']
      sitelibdir = Config::CONFIG['sitelibdir']
      @prefix = ENV['PREFIX'] || ruby_prefix
      if @prefix == ruby_prefix
        @rubylib = sitelibdir
      else
        libpart = sitelibdir[ruby_prefix.size .. -1]
        @rubylib = File.join(@prefix, libpart)
      end
      @groups = []
    end

    def groups
      if @groups.empty?
        @groups.push(*default_installation)
      end
      @groups
    end

    def default_installation
      default_groups = base_installation
      default_groups.push(*icon_installation)
      default_groups
    end

    def base_installation
      [
       ['lib',  build.files.libs,     rubylib,  0644],
       ['data', build.files.data,     sharedir, 0644],
       ['bin',  build.files.programs, bindir,   0755]
      ]
    end

    def icon_installation
      icon_dir = File.join(sharedir, 'icons', 'hicolor')
      icon_group = []
      build.files.icons.each do |filename|
        filename =~ /.*\/(.+)\/.+/
        size = $1
        dest = File.join(icon_dir, size, 'apps')
        icon_group << [File.dirname(filename), filename, dest, 0644]
      end
      icon_group
    end

    def bindir
      File.join(@prefix, 'bin')
    end
    def sharedir
      File.join(@prefix, 'share')
    end
    def appsharedir
      File.join(sharedir, build.name)
    end
  end

  ## # # # debian # # # ##

  def stage_install_file(src_dir, file, dest_dir, mode)
    stage_dest = File.join(@debinstall.staging_dir, dest_dir)
    install_file(src_dir, file, stage_dest, mode)
  end

  def stage_install_file_src(file, mode)
    dest = File.join(@debinstall.staging_dir_src, File.dirname(file))
    FileUtils.mkdir_p dest unless test ?d, dest
    puts "Installing #{file} to #{dest}"
    File.install(file, dest, mode)
  end

  def template_copy(src, dest, data)
    src_text = File.open(src).read()
    dest_text = src_text.gsub(/#(\w+)#/) { |match| data[$1.intern] }
    FileUtils.mkdir_p(File.dirname(dest))
    File.open(dest, 'w') { |f| f.write(dest_text) }
  end

  def define_debinstall_tasks
    namespace "debian" do

      task :stage_install_files do # HACK cut-n-paste blues!
        @debinstall.groups.each do |src, files, dest, mode|
          files.each do |file|
            stage_install_file(src, file, dest, mode)
          end
        end
      end

      task :stage_install_files_src do 
        @debinstall.groups.each do |src, files, dest, mode|
          files.each do |file|
            stage_install_file_src(file, mode)
          end
        end
        ['Rakefile', 'tasks.rb', 'debian/rules', 'debian/changelog', 'debian/control', 'debian/copyright'].each { |f| stage_install_file_src(f, 0644)}
      end

      task :stage_install => [:pre_install, :stage_install_files] do
        stage_install_file('lib', "lib/sradio/config.rb", @debinstall.rubylib, 0644)
        puts "HACK:: installing -> 'lib', 'lib/sradio/config.rb' #{@debinstall.rubylib}"
      end

      task :deb_files => [:stage_install] do
        # create dir
        debian_dir = File.join(@debinstall.staging_dir, "DEBIAN")
        FileUtils.mkdir_p(debian_dir)

        # create DEBIAN/control and debian/files
        `dpkg-gencontrol -isp`
      end

      ## obviously this task needs 'fakeroot' and 'dpkg' to be installed
      task :build_deb => [:deb_files] do

        puts "Creating deb file #{@debinstall.deb}"
        debfile = File.join(File.dirname(@debinstall.staging_dir), @debinstall.deb)
        msg = `fakeroot dpkg-deb --build #{@debinstall.staging_dir} #{debfile}`
        puts msg
      end

      task :build_src => [:stage_install_files_src] do 
        puts "Creating source stuff."
        pwd = `pwd`
        msg = `cd #{@debinstall.staging_dir_src} && debuild -S -sa`
        puts msg
        `cd #{pwd}`
      end

      task :deb_clean do
        FileUtils.rm_rf(@debinstall.staging_dir)
        FileUtils.rm_rf(Pathname.new(@debinstall.staging_dir_src).parent.to_s)
        FileUtils.rm_rf("debian/files")
        FileUtils.rm_rf("build-stamp")
      end

      task :deb_clobber do |t|
        debfile = File.join(File.dirname(@debinstall.staging_dir), @debinstall.deb)
        FileUtils.rm_f(debfile)
      end

      desc "Create a deb file"
      task :deb => [:build_deb, :deb_clean]

    end
    task :clean => ["debian:deb_clean"]
    task :clobber => ["debian:deb_clobber"]

  end

  class DebianInstallConfig < InstallConfig

    attr_accessor :staging_dir, :staging_dir_src, :deb

    # Debian is peculiar about where it installs ruby libraries.
    # Its 'sitelibdir' (for ruby 1.8) is /usr/local/lib/site_ruby/1.8
    # According to the Linux Standards Base (LSB) a package manager
    # should not install anything to /usr/local
    # So, to install to /usr/lib/ruby, deb files will install to
    # 'rubylibdir' instead (this is /usr/lib/ruby/1.8)
    def initialize(build)
      super(build)
      ruby_prefix = Config::CONFIG['prefix']
      sitelibdir = Config::CONFIG['rubylibdir']
      @prefix = ENV['PREFIX'] || ruby_prefix
      if @prefix == ruby_prefix
        @rubylib = sitelibdir
      else
        libpart = sitelibdir[ruby_prefix.size .. -1]
        @rubylib = File.join(@prefix, libpart)
      end
      @groups = []
      @staging_dir = nil
      @staging_dir_src = nil
      @deb = "#{build.name}_#{build.version}_all.deb"
    end

  end
end
